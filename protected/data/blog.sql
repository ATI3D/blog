-- phpMyAdmin SQL Dump
-- version 2.10.3
-- http://www.phpmyadmin.net
-- 
-- Хост: localhost
-- Время создания: Ноя 23 2011 г., 14:39
-- Версия сервера: 5.0.51
-- Версия PHP: 5.2.6

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";

-- 
-- База данных: `blog`
-- 

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_core_config`
-- 

CREATE TABLE `tbl_core_config` (
  `id` int(11) NOT NULL auto_increment,
  `group` varchar(255) NOT NULL,
  `key` varchar(255) NOT NULL,
  `value` varchar(255) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_core_config`
-- 

INSERT INTO `tbl_core_config` VALUES (1, 'core', 'name', 'Тестовый Блог');
INSERT INTO `tbl_core_config` VALUES (2, 'core', 'language', 'ru');

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_lookup`
-- 

CREATE TABLE `tbl_lookup` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(128) collate utf8_unicode_ci NOT NULL,
  `code` int(11) NOT NULL,
  `type` varchar(128) collate utf8_unicode_ci NOT NULL,
  `position` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=6 ;

-- 
-- Дамп данных таблицы `tbl_lookup`
-- 

INSERT INTO `tbl_lookup` VALUES (1, 'Черновик', 1, 'PostStatus', 1);
INSERT INTO `tbl_lookup` VALUES (2, 'Опубликован', 2, 'PostStatus', 2);
INSERT INTO `tbl_lookup` VALUES (3, 'Архив', 3, 'PostStatus', 3);
INSERT INTO `tbl_lookup` VALUES (4, 'Pending Approval', 1, 'CommentStatus', 1);
INSERT INTO `tbl_lookup` VALUES (5, 'Approved', 2, 'CommentStatus', 2);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_pages`
-- 

CREATE TABLE `tbl_pages` (
  `id` tinyint(2) NOT NULL auto_increment,
  `name` varchar(255) NOT NULL,
  `slug` varchar(255) NOT NULL,
  `title` varchar(255) NOT NULL,
  `description` varchar(200) NOT NULL,
  `keywords` varchar(200) NOT NULL,
  `text` text NOT NULL,
  `update_time` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_pages`
-- 

INSERT INTO `tbl_pages` VALUES (1, 'О нас', 'o_nas', 'О нас', 'О нас', 'О нас', '<p>Здарово! Я еще не до конца определился, что это будет. Но скорее всего это будет личный блог. Такого УГ в рунете валом, почему бы не пополнить счет еще одним образцом?! (:</p>\r\n<p><img title="Yii Framework" src="http://localhost/blog/upload/images/logo.png" alt="Yii Framework" width="173" height="40" /></p>', 1321963029);
INSERT INTO `tbl_pages` VALUES (2, 'Контакты', 'kontakti', 'Контакты', 'Контакты', 'Контакты', '<p>Twitter: AlexATI</p>', 1322058793);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_post`
-- 

CREATE TABLE `tbl_post` (
  `id` int(11) NOT NULL auto_increment,
  `user_id` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `short_content` text NOT NULL,
  `tags` text NOT NULL,
  `status` tinyint(1) NOT NULL,
  `rating` int(11) NOT NULL,
  `create_time` int(11) NOT NULL,
  `update_time` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;

-- 
-- Дамп данных таблицы `tbl_post`
-- 

INSERT INTO `tbl_post` VALUES (1, 1, 'Календарные типы данных в MySQL: особенности использования', '<p>В MySQL 5 есть несколько типов данных для хранения даты и времени. Это TIMESTAMP, DATE, DATETIME, TIME и YEAR. Все они обладают своими особенностями, и выбор в пользу того или иного календарного типа должен производиться отдельно в каждой конкретной ситуации. Я хотел бы поделиться с вами результатом моего сегодняшнего миниисследования этих типов, в том числе в аспекте работы с временными зонами.</p>\r\n<!--cut-->\r\n<p>Итак, все календарные типы данных подробно описаны в разделе &laquo;10.3.&nbsp;<a href="http://dev.mysql.com/doc/refman/5.1/en/date-and-time-types.html">Date and Time Types</a>&raquo; руководства по MySQL. А важная информация, касающаяся поддержки СУБД временных зон, расписана в разделе &laquo;9.7.<a href="http://dev.mysql.com/doc/refman/5.1/en/time-zone-support.html">MySQL Server Time Zone Support</a>&raquo;. Все следующее далее базируется на изучении руководства. В то же время, в здесь указаны лишь нюансы выбора в пользу того или иного типа, поэтому этот материал никак не заменяет мануал, но дополняет его.<br /><br />Вначале краткая характеристика каждого из типов:&nbsp;</p>\r\n<ul>\r\n<li>TIMESTAMP &mdash; тип данных для хранения даты и времени. Данные хранятся в виде количества секунд, прошедших с начала &laquo;эпохи Юникса&raquo;. Диапазон значений: 1970-01-01 00:00:00 &mdash; 2038-12-31 00:00:00. Занимает 4 байта.</li>\r\n<li>YEAR &mdash; тип данных для хранения года. Диапазон значений: 1901 &mdash; 2155. Занимает 1 байт.</li>\r\n<li>DATE &mdash; тип данных для хранения даты. Диапазон значений: 1000-01-01 &mdash; 9999-12-31. Занимает 3 байта.</li>\r\n<li>TIME &mdash; тип данных для хранения времени. Диапазон значений: &minus;828:59:59 &mdash; 828:59:59. Занимает 3 байта.</li>\r\n<li>DATETIME &mdash; тип данных для хранения даты и времени. Диапазон значений: 1000-01-01 00:00:00 &mdash; 9999-12-31 00:00:00. Занимает 8 байт.</li>\r\n</ul>\r\n<p><br /><em>Хозяйке на заметку</em>. Интересно то, что большинство программистов полагают, что понятие &laquo;timestamp&raquo; &mdash; это и есть Unix-время. На самом же деле,&nbsp;<a href="http://en.wikipedia.org/wiki/Timestamp">timestamp</a>&nbsp;&mdash; это метка, которая представляет собой последовательность символов, обозначающих дату и / или время, когда определенное событие произошло. А &laquo;<a href="http://en.wikipedia.org/wiki/Unix_time">время Юникса</a>&raquo; (Unix time) или POSIX time &mdash; это количество секунд, прошедших с полуночи 1 января 1970 года по UTC. Понятие timestamp шире, чем Unix time.<br /><br />Проанализировав описание типов, представленное выше, можно сделать практически все выводы о достоинствах и недостатках тех или иных типов. Все довольно просто и очевидно.<br /><br />Но прежде, чем рассказать об использовании этих типов, хочу заметить, что на практике часто используется другой тип для хранения даты и времени: целочисленное значение (для хранения даты &mdash; INT (4 байта), даты и времени &mdash; BIGINT (8 байт)). Отличие использования целочисленных типов от DATE и DATETIME лишь в том, что при выводе данные не форматируются, а в вычислениях с датами и временем целые числа требуется преобразовывать в соответствующий календарный тип. Кроме того, не производится проверка на валидность представленного значения перед сохранением. Возможности сортировки сохраняются. Поэтому INT и BIGINT имеет смысл использовать в тех же случаях, как DATE и DATETIME, с целью максимизации переносимости и независимости от СУБД. Других преимуществ я не вижу, если они есть, предлагаю указать в комментах.<br /><br /></p>\r\n<h2>Использование календарных типов данный в MySQL</h2>\r\n<p><br />Начнем с самого простого &mdash; тип&nbsp;<strong>YEAR</strong>. Единственное его достоинство &mdash; малый размер &mdash; всего-то 1 байт. Но из-за этого действует строгое ограничение по диапазону допустимых значений (тип может хранить только 255 разных значений). Мне сложно представить практическую ситуацию, когда может потребоваться хранить года строго в диапазоне от 1901 до 2155. Кроме того, тип SMALLINT (2 байта) дает диапазон, достаточный в большинстве ситуаций для хранения года. А экономить 1 байт на строке в таблице БД в наше время смысла нет.<br /><br />Типы&nbsp;<strong>DATE</strong>&nbsp;и&nbsp;<strong>DATETIME</strong>&nbsp;можно объединить в одну группу. Они хранят дату или дату и время с довольно широким диапазоном допустимых значений, независимую от установленной на сервере временной зоны. Их использование определенно имеет практический смысл. Но если требуется хранить даты исторических событий, уходящие в прошлое за Нашу эру, придется выбрать другие типы данных. Для хранения дат неких событий, потенциально выходящих за рамки диапазона типа TIMESTAMP (дни рождений, даты выпуска продуктов, избрания президентов, запуски космических ракет и т.д.), отлично подойдут эти типы. При использовании этих типов нужно учитывать один важный нюанс, но об этом ниже.<br /><br />Тип&nbsp;<strong>TIME</strong>&nbsp;можно использовать для хранения промежутка времени, когда не нужна точность меньше 1 секунды, и промежутки времени меньше 829 часов. Добавить тут больше нечего.<br /><br />Остался самый интересный тип &mdash;&nbsp;<strong>TIMESTAMP</strong>. Рассматривать его надо в сравнении с DATE и DATETIME: TIMESTAMP тоже предназначен для хранения даты и/или времени происхождения неких событий. Важное отличие между ними в диапазонах значений: очевидно, что TIMESTAMP не годится для хранения исторических событий (даже таких, как дни рождений), но отлично подходит для хранения текущих (логирование, даты размещения статей, добавления товаров, оформления заказов) и предстоящих в обозримом будущем событий (выходы новых версий, календари и планировщики и т.д).<br /><br />Основное удобство использования типа TIMESTAMP состоит в том, что для столбцов этого типа в таблицах можно задавать значение по умолчанию в виде подстановки текущего времени, а так же установки текущего времени при обновлении записи. Если вам требуется эти возможности, то с вероятностью 99% TIMESTAMP &mdash; именно то, что вам нужно. (Как этоделать, смотрите в мануале.)<br /><br />Не стоит бояться того, что с приближением к 2038 году ваш софт перестанет работать. Во-первых, до этого времени вашим софтом, скорее всего, просто перестанут пользоваться (особенно версиями, которые пишутся сейчас). Во-вторых, с приближением к этой дате разработчики MySQL обязательно что-нибудь придумают для сохранения работоспособности вашего софта. Все решится так же хорошо, как проблема Y2K.<br /><br />Итак, тип TIMESTAMP используем для хранения дат и времени свершения событий нашего времени, а DATETIME и DATE &mdash; для хранения дат и времени свершения исторических событий, или событий глубокого будущего.<br /><br />Диапазоны значений &mdash; это важное отличие между типами TIMESTAMP, DATETIME и DATE, но не главное.<strong>Главное</strong>&nbsp;то, что TIMESTAMP хранит значение в&nbsp;<a href="http://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a>. При сохранении значения оно переводится из текущего временной зоны в UTC, а при его чтении &mdash; во время текущей временной зоны из UTC. DATETIME и DATE хранят и выводят всегда одно и то же время, независимо от временных зон.<br /><br />Временные зоны&nbsp;<a href="http://dev.mysql.com/doc/refman/5.1/en/time-zone-support.html">устанавливаются</a>&nbsp;в СУБД MySQL глобально или&nbsp;<strong>для текущего подключения</strong>.<strong>Последнее можно использовать для обеспечения работы разных пользователей в разных временных зонах на уровне СУБД</strong>. Все значения времени физически будут храниться в UTC, а приниматься от клиента и отдаваться клинту &mdash; в значениях его временной зоны. Но только при использовании типа данных TIMESTAMP. DATE и DATETIME всегда принимают, хранят и отдают одно и то же значение.<br /><br />Функция NOW() и ее синонимы возвращают значение времени в текущей временной зоне пользователя.<br /><br />Учитывая все эти обстоятельства, необходимо быть крайне внимательными при изменении временной зоны в пределах подключения к серверу и использовании типов DATE и DATETIME. Если надо хранить дату (например, дату рождения), то никаких проблем не будет. Дата рождения в любой зоне одинаковая. Т.е. если вы родились 1 января в 0:00 UTC/GMT+0, то это&nbsp;<strong>не</strong>&nbsp;значит, что в Америке будут праздновать ваш день рождения 31 декабря. Но если вы решите хранить&nbsp;<strong>время</strong>&nbsp;события в столбце DATETIME, то тут уже построить работу с пользовательскими временными зонами на уровне СУБД просто не выйдет. Поясню на примере:<br /><br />Пользователь X работает в зоне UTC/GMT+2, Y &mdash; в зоне UTC/GMT+3. Для соединений пользователей с MySQL установлена соответствующая (у каждого своя) временная зона. Пользователь размещает сообщение на форуме, нас интересует дата написания сообщения.<br /><br />Вариант 1: DATETIME. Пользователь X пишет сообщение в 14:00 UTC/GMT+2. Значение в поле &laquo;дата&raquo; сообщения подставляется как результат выполнения функции NOW() &mdash; 14:00. Пользователь Y считывает время написания сообщения и видит те же 14:00. Но у него в настройках стоитзона UTC/GMT+3, и он думает, что сообщение было написано не только что, а час назад.<br /><br />Вариант 2: TIMESTAMP. Пользователь X пишет сообщение в 14:00 UTC/GMT+2. В поле &laquo;дата&raquo; попадает результат выполнения функции NOW() &mdash; в данном случае &mdash; 12:00 UTC/GMT+0. ПользовательY считывает время написания сообщения и получает (UTC/GMT+3)(12:00 UTC/GMT+0) = 15:00 UTC/GMT+3. Все получается ровно так, как мы хотим. И главное &mdash; пользоваться этим крайне удобно: для поддержки пользовательских временных зон не нужно писать никакой код приведения времени.<br /><br />Возможности подстановки текущего времени и работы с временными зонами в типе TIMESTAMP настолько весомы, что если вам в неком логе надо хранить дату без времени, все равно стоит использовать TIMESTAMP, вместо DATE, не экономя 1 байт разницы между ними. При этом на &laquo;00:00:00&raquo; просто не обращать внимания.<br /><br />Если же вы не можете использовать TIMESTAMP из-за относительно малого диапазона его значений (а обычно это 1&mdash;2 случая против 10&mdash;15 в базе сайта), придется использовать DATETIME и аккуратно его корректировать значения в нужных местах (т.е. при записи в это поле переводить дату в UTC, а при чтении &mdash; во время в зоне считывающего пользователя). Если вы храните только дату, то скорее всего не важно, какая у вас временная зона: новый год все празднуют 1 января по локальному времени, ничего переводить тут не понадобится.</p>', '<p>В MySQL 5 есть несколько типов данных для хранения даты и времени. Это TIMESTAMP, DATE, DATETIME, TIME и YEAR. Все они обладают своими особенностями, и выбор в пользу того или иного календарного типа должен производиться отдельно в каждой конкретной ситуации. Я хотел бы поделиться с вами результатом моего сегодняшнего миниисследования этих типов, в том числе в аспекте работы с временными зонами.</p>\r\n', 'date, yii', 2, 0, 1322047670, 1322058560);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_tag`
-- 

CREATE TABLE `tbl_tag` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(128) collate utf8_unicode_ci NOT NULL,
  `frequency` int(11) default '1',
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=5 ;

-- 
-- Дамп данных таблицы `tbl_tag`
-- 

INSERT INTO `tbl_tag` VALUES (1, 'yii', 2);
INSERT INTO `tbl_tag` VALUES (2, 'blog', 1);
INSERT INTO `tbl_tag` VALUES (3, 'test', 1);
INSERT INTO `tbl_tag` VALUES (4, 'date', 1);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_user`
-- 

CREATE TABLE `tbl_user` (
  `id` int(11) NOT NULL auto_increment,
  `group_id` int(11) NOT NULL default '0',
  `username` varchar(128) NOT NULL,
  `password` varchar(128) NOT NULL,
  `role` varchar(128) NOT NULL,
  `create_time` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_user`
-- 

INSERT INTO `tbl_user` VALUES (1, 2, 'admin', '4d7a85863bf3861a5523407eab522010', 'administrator', 1321448929);
INSERT INTO `tbl_user` VALUES (2, 1, 'ATI', '4d7a85863bf3861a5523407eab522010', 'moderator', 1321467751);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_user_group`
-- 

CREATE TABLE `tbl_user_group` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(255) NOT NULL,
  `slug` varchar(255) NOT NULL,
  `level` int(11) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_user_group`
-- 

INSERT INTO `tbl_user_group` VALUES (1, 'Тестовики', 'administrators', 1);
INSERT INTO `tbl_user_group` VALUES (2, 'Команда Тестеров', 'tester_team', 1);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_user_profile`
-- 

CREATE TABLE `tbl_user_profile` (
  `id` int(11) NOT NULL auto_increment,
  `user_id` int(11) NOT NULL,
  `first_name` varchar(255) NOT NULL,
  `last_name` varchar(255) NOT NULL,
  `email` varchar(255) NOT NULL,
  `phone` varchar(255) NOT NULL,
  `birthday` date NOT NULL,
  `avatar` varchar(255) NOT NULL,
  `level` tinyint(3) NOT NULL,
  `last_login` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_user_profile`
-- 

INSERT INTO `tbl_user_profile` VALUES (1, 1, 'Alexander', 'Stanovoy', 'soccer007@mail.ru', '', '1988-07-13', '19_11_2011_13_02_26_admin.jpg', 1, 1321449007);
INSERT INTO `tbl_user_profile` VALUES (2, 2, '', '', 'ati@mail.ru', '', '1988-07-13', '19_11_2011_13_00_56_ATI.gif', 0, 0);
