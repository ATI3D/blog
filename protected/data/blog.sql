-- phpMyAdmin SQL Dump
-- version 2.10.3
-- http://www.phpmyadmin.net
-- 
-- Хост: localhost
-- Время создания: Ноя 24 2011 г., 00:12
-- Версия сервера: 5.0.51
-- Версия PHP: 5.2.6

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";

-- 
-- База данных: `blog`
-- 

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_core_config`
-- 

CREATE TABLE `tbl_core_config` (
  `id` int(11) NOT NULL auto_increment,
  `group` varchar(255) NOT NULL,
  `key` varchar(255) NOT NULL,
  `value` varchar(255) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_core_config`
-- 

INSERT INTO `tbl_core_config` VALUES (1, 'core', 'name', 'Тестовый Блог');
INSERT INTO `tbl_core_config` VALUES (2, 'core', 'language', 'ru');

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_lookup`
-- 

CREATE TABLE `tbl_lookup` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(128) collate utf8_unicode_ci NOT NULL,
  `code` int(11) NOT NULL,
  `type` varchar(128) collate utf8_unicode_ci NOT NULL,
  `position` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=6 ;

-- 
-- Дамп данных таблицы `tbl_lookup`
-- 

INSERT INTO `tbl_lookup` VALUES (1, 'Черновик', 1, 'PostStatus', 1);
INSERT INTO `tbl_lookup` VALUES (2, 'Опубликован', 2, 'PostStatus', 2);
INSERT INTO `tbl_lookup` VALUES (3, 'Архив', 3, 'PostStatus', 3);
INSERT INTO `tbl_lookup` VALUES (4, 'Pending Approval', 1, 'CommentStatus', 1);
INSERT INTO `tbl_lookup` VALUES (5, 'Approved', 2, 'CommentStatus', 2);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_pages`
-- 

CREATE TABLE `tbl_pages` (
  `id` tinyint(2) NOT NULL auto_increment,
  `name` varchar(255) NOT NULL,
  `slug` varchar(255) NOT NULL,
  `title` varchar(255) NOT NULL,
  `description` varchar(200) NOT NULL,
  `keywords` varchar(200) NOT NULL,
  `text` text NOT NULL,
  `update_time` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_pages`
-- 

INSERT INTO `tbl_pages` VALUES (1, 'О нас', 'o_nas', 'О нас', 'О нас', 'О нас', '<p>Здарово! Я еще не до конца определился, что это будет. Но скорее всего это будет личный блог. Такого УГ в рунете валом, почему бы не пополнить счет еще одним образцом?! (:</p>\r\n<p><img title="Yii Framework" src="http://localhost/blog/upload/images/logo.png" alt="Yii Framework" width="173" height="40" /></p>', 1321963029);
INSERT INTO `tbl_pages` VALUES (2, 'Контакты', 'kontakti', 'Контакты', 'Контакты', 'Контакты', '<p>Twitter: AlexATI</p>', 1322058793);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_post`
-- 

CREATE TABLE `tbl_post` (
  `id` int(11) NOT NULL auto_increment,
  `user_id` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `short_content` text NOT NULL,
  `tags` text NOT NULL,
  `status` tinyint(1) NOT NULL,
  `rating` int(11) NOT NULL,
  `create_time` int(11) NOT NULL,
  `update_time` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=4 ;

-- 
-- Дамп данных таблицы `tbl_post`
-- 

INSERT INTO `tbl_post` VALUES (1, 1, 'Календарные типы данных в MySQL: особенности использования', '<p>В MySQL 5 есть несколько типов данных для хранения даты и времени. Это TIMESTAMP, DATE, DATETIME, TIME и YEAR. Все они обладают своими особенностями, и выбор в пользу того или иного календарного типа должен производиться отдельно в каждой конкретной ситуации. Я хотел бы поделиться с вами результатом моего сегодняшнего миниисследования этих типов, в том числе в аспекте работы с временными зонами.</p>\r\n<!--cut-->\r\n<p>Итак, все календарные типы данных подробно описаны в разделе &laquo;10.3.&nbsp;<a href="http://dev.mysql.com/doc/refman/5.1/en/date-and-time-types.html">Date and Time Types</a>&raquo; руководства по MySQL. А важная информация, касающаяся поддержки СУБД временных зон, расписана в разделе &laquo;9.7.<a href="http://dev.mysql.com/doc/refman/5.1/en/time-zone-support.html">MySQL Server Time Zone Support</a>&raquo;. Все следующее далее базируется на изучении руководства. В то же время, в здесь указаны лишь нюансы выбора в пользу того или иного типа, поэтому этот материал никак не заменяет мануал, но дополняет его.<br /><br />Вначале краткая характеристика каждого из типов:&nbsp;</p>\r\n<ul>\r\n<li>TIMESTAMP &mdash; тип данных для хранения даты и времени. Данные хранятся в виде количества секунд, прошедших с начала &laquo;эпохи Юникса&raquo;. Диапазон значений: 1970-01-01 00:00:00 &mdash; 2038-12-31 00:00:00. Занимает 4 байта.</li>\r\n<li>YEAR &mdash; тип данных для хранения года. Диапазон значений: 1901 &mdash; 2155. Занимает 1 байт.</li>\r\n<li>DATE &mdash; тип данных для хранения даты. Диапазон значений: 1000-01-01 &mdash; 9999-12-31. Занимает 3 байта.</li>\r\n<li>TIME &mdash; тип данных для хранения времени. Диапазон значений: &minus;828:59:59 &mdash; 828:59:59. Занимает 3 байта.</li>\r\n<li>DATETIME &mdash; тип данных для хранения даты и времени. Диапазон значений: 1000-01-01 00:00:00 &mdash; 9999-12-31 00:00:00. Занимает 8 байт.</li>\r\n</ul>\r\n<p><br /><em>Хозяйке на заметку</em>. Интересно то, что большинство программистов полагают, что понятие &laquo;timestamp&raquo; &mdash; это и есть Unix-время. На самом же деле,&nbsp;<a href="http://en.wikipedia.org/wiki/Timestamp">timestamp</a>&nbsp;&mdash; это метка, которая представляет собой последовательность символов, обозначающих дату и / или время, когда определенное событие произошло. А &laquo;<a href="http://en.wikipedia.org/wiki/Unix_time">время Юникса</a>&raquo; (Unix time) или POSIX time &mdash; это количество секунд, прошедших с полуночи 1 января 1970 года по UTC. Понятие timestamp шире, чем Unix time.<br /><br />Проанализировав описание типов, представленное выше, можно сделать практически все выводы о достоинствах и недостатках тех или иных типов. Все довольно просто и очевидно.<br /><br />Но прежде, чем рассказать об использовании этих типов, хочу заметить, что на практике часто используется другой тип для хранения даты и времени: целочисленное значение (для хранения даты &mdash; INT (4 байта), даты и времени &mdash; BIGINT (8 байт)). Отличие использования целочисленных типов от DATE и DATETIME лишь в том, что при выводе данные не форматируются, а в вычислениях с датами и временем целые числа требуется преобразовывать в соответствующий календарный тип. Кроме того, не производится проверка на валидность представленного значения перед сохранением. Возможности сортировки сохраняются. Поэтому INT и BIGINT имеет смысл использовать в тех же случаях, как DATE и DATETIME, с целью максимизации переносимости и независимости от СУБД. Других преимуществ я не вижу, если они есть, предлагаю указать в комментах.<br /><br /></p>\r\n<h2>Использование календарных типов данный в MySQL</h2>\r\n<p><br />Начнем с самого простого &mdash; тип&nbsp;<strong>YEAR</strong>. Единственное его достоинство &mdash; малый размер &mdash; всего-то 1 байт. Но из-за этого действует строгое ограничение по диапазону допустимых значений (тип может хранить только 255 разных значений). Мне сложно представить практическую ситуацию, когда может потребоваться хранить года строго в диапазоне от 1901 до 2155. Кроме того, тип SMALLINT (2 байта) дает диапазон, достаточный в большинстве ситуаций для хранения года. А экономить 1 байт на строке в таблице БД в наше время смысла нет.<br /><br />Типы&nbsp;<strong>DATE</strong>&nbsp;и&nbsp;<strong>DATETIME</strong>&nbsp;можно объединить в одну группу. Они хранят дату или дату и время с довольно широким диапазоном допустимых значений, независимую от установленной на сервере временной зоны. Их использование определенно имеет практический смысл. Но если требуется хранить даты исторических событий, уходящие в прошлое за Нашу эру, придется выбрать другие типы данных. Для хранения дат неких событий, потенциально выходящих за рамки диапазона типа TIMESTAMP (дни рождений, даты выпуска продуктов, избрания президентов, запуски космических ракет и т.д.), отлично подойдут эти типы. При использовании этих типов нужно учитывать один важный нюанс, но об этом ниже.<br /><br />Тип&nbsp;<strong>TIME</strong>&nbsp;можно использовать для хранения промежутка времени, когда не нужна точность меньше 1 секунды, и промежутки времени меньше 829 часов. Добавить тут больше нечего.<br /><br />Остался самый интересный тип &mdash;&nbsp;<strong>TIMESTAMP</strong>. Рассматривать его надо в сравнении с DATE и DATETIME: TIMESTAMP тоже предназначен для хранения даты и/или времени происхождения неких событий. Важное отличие между ними в диапазонах значений: очевидно, что TIMESTAMP не годится для хранения исторических событий (даже таких, как дни рождений), но отлично подходит для хранения текущих (логирование, даты размещения статей, добавления товаров, оформления заказов) и предстоящих в обозримом будущем событий (выходы новых версий, календари и планировщики и т.д).<br /><br />Основное удобство использования типа TIMESTAMP состоит в том, что для столбцов этого типа в таблицах можно задавать значение по умолчанию в виде подстановки текущего времени, а так же установки текущего времени при обновлении записи. Если вам требуется эти возможности, то с вероятностью 99% TIMESTAMP &mdash; именно то, что вам нужно. (Как этоделать, смотрите в мануале.)<br /><br />Не стоит бояться того, что с приближением к 2038 году ваш софт перестанет работать. Во-первых, до этого времени вашим софтом, скорее всего, просто перестанут пользоваться (особенно версиями, которые пишутся сейчас). Во-вторых, с приближением к этой дате разработчики MySQL обязательно что-нибудь придумают для сохранения работоспособности вашего софта. Все решится так же хорошо, как проблема Y2K.<br /><br />Итак, тип TIMESTAMP используем для хранения дат и времени свершения событий нашего времени, а DATETIME и DATE &mdash; для хранения дат и времени свершения исторических событий, или событий глубокого будущего.<br /><br />Диапазоны значений &mdash; это важное отличие между типами TIMESTAMP, DATETIME и DATE, но не главное.<strong>Главное</strong>&nbsp;то, что TIMESTAMP хранит значение в&nbsp;<a href="http://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a>. При сохранении значения оно переводится из текущего временной зоны в UTC, а при его чтении &mdash; во время текущей временной зоны из UTC. DATETIME и DATE хранят и выводят всегда одно и то же время, независимо от временных зон.<br /><br />Временные зоны&nbsp;<a href="http://dev.mysql.com/doc/refman/5.1/en/time-zone-support.html">устанавливаются</a>&nbsp;в СУБД MySQL глобально или&nbsp;<strong>для текущего подключения</strong>.<strong>Последнее можно использовать для обеспечения работы разных пользователей в разных временных зонах на уровне СУБД</strong>. Все значения времени физически будут храниться в UTC, а приниматься от клиента и отдаваться клинту &mdash; в значениях его временной зоны. Но только при использовании типа данных TIMESTAMP. DATE и DATETIME всегда принимают, хранят и отдают одно и то же значение.<br /><br />Функция NOW() и ее синонимы возвращают значение времени в текущей временной зоне пользователя.<br /><br />Учитывая все эти обстоятельства, необходимо быть крайне внимательными при изменении временной зоны в пределах подключения к серверу и использовании типов DATE и DATETIME. Если надо хранить дату (например, дату рождения), то никаких проблем не будет. Дата рождения в любой зоне одинаковая. Т.е. если вы родились 1 января в 0:00 UTC/GMT+0, то это&nbsp;<strong>не</strong>&nbsp;значит, что в Америке будут праздновать ваш день рождения 31 декабря. Но если вы решите хранить&nbsp;<strong>время</strong>&nbsp;события в столбце DATETIME, то тут уже построить работу с пользовательскими временными зонами на уровне СУБД просто не выйдет. Поясню на примере:<br /><br />Пользователь X работает в зоне UTC/GMT+2, Y &mdash; в зоне UTC/GMT+3. Для соединений пользователей с MySQL установлена соответствующая (у каждого своя) временная зона. Пользователь размещает сообщение на форуме, нас интересует дата написания сообщения.<br /><br />Вариант 1: DATETIME. Пользователь X пишет сообщение в 14:00 UTC/GMT+2. Значение в поле &laquo;дата&raquo; сообщения подставляется как результат выполнения функции NOW() &mdash; 14:00. Пользователь Y считывает время написания сообщения и видит те же 14:00. Но у него в настройках стоитзона UTC/GMT+3, и он думает, что сообщение было написано не только что, а час назад.<br /><br />Вариант 2: TIMESTAMP. Пользователь X пишет сообщение в 14:00 UTC/GMT+2. В поле &laquo;дата&raquo; попадает результат выполнения функции NOW() &mdash; в данном случае &mdash; 12:00 UTC/GMT+0. ПользовательY считывает время написания сообщения и получает (UTC/GMT+3)(12:00 UTC/GMT+0) = 15:00 UTC/GMT+3. Все получается ровно так, как мы хотим. И главное &mdash; пользоваться этим крайне удобно: для поддержки пользовательских временных зон не нужно писать никакой код приведения времени.<br /><br />Возможности подстановки текущего времени и работы с временными зонами в типе TIMESTAMP настолько весомы, что если вам в неком логе надо хранить дату без времени, все равно стоит использовать TIMESTAMP, вместо DATE, не экономя 1 байт разницы между ними. При этом на &laquo;00:00:00&raquo; просто не обращать внимания.<br /><br />Если же вы не можете использовать TIMESTAMP из-за относительно малого диапазона его значений (а обычно это 1&mdash;2 случая против 10&mdash;15 в базе сайта), придется использовать DATETIME и аккуратно его корректировать значения в нужных местах (т.е. при записи в это поле переводить дату в UTC, а при чтении &mdash; во время в зоне считывающего пользователя). Если вы храните только дату, то скорее всего не важно, какая у вас временная зона: новый год все празднуют 1 января по локальному времени, ничего переводить тут не понадобится.</p>', '<p>В MySQL 5 есть несколько типов данных для хранения даты и времени. Это TIMESTAMP, DATE, DATETIME, TIME и YEAR. Все они обладают своими особенностями, и выбор в пользу того или иного календарного типа должен производиться отдельно в каждой конкретной ситуации. Я хотел бы поделиться с вами результатом моего сегодняшнего миниисследования этих типов, в том числе в аспекте работы с временными зонами.</p>\r\n', 'date, yii', 2, 0, 1322047670, 1322058560);
INSERT INTO `tbl_post` VALUES (2, 1, 'Что такое Yii?', '<p>Yii &mdash; это высокоэффективный основанный на компонентной структуре PHP-фреймворк для разработки масштабных веб-приложений. Он позволяет максимально применить концепцию повторного использования кода и может существенно ускорить процесс веб-разработки. Название Yii (произносится как Yee или [ji:]) означает простой (easy), эффективный (efficient) и расширяемый (extensible).</p>\r\n<!--cut-->', '<p>Yii &mdash; это высокоэффективный основанный на компонентной структуре PHP-фреймворк для разработки масштабных веб-приложений. Он позволяет максимально применить концепцию повторного использования кода и может существенно ускорить процесс веб-разработки. Название Yii (произносится как Yee или [ji:]) означает простой (easy), эффективный (efficient) и расширяемый (extensible).</p>\r\n', 'yii', 2, 0, 1322077530, 1322077571);
INSERT INTO `tbl_post` VALUES (3, 2, '31 метод эффективного программирования под Android', '<p>Данная статья является переводом очень хорошего <a href="http://stackoverflow.com/questions/2961049/effective-android-programming-techniques">топика</a> с форума Stack Overflow. Так как английский язык не является для меня  родным, то какие-либо непонятные мне места я просто пропускал, что бы не  разгневать тех, кто его действительно знает. Статья содержит список  советов и рекомендаций для начинающих разработчиков под Android.</p>\r\n<!--cut-->\r\n<p>1. <strong>Не забывайте освобождать ресурсы после использования</strong>: многие  ресурсы, такие как курсоры баз данных часто игнорируют. Освобождайте их.  Закрывайте ресурсы (файлы, потоки) после того, как они больше вам не  нужны.<br /> 2. <strong>Не используйте &laquo;магические&raquo; числа</strong>: записи вида values[0] &mdash; бессмысленны. Существуют элегантные способы доступа, такие как values[SensorManager.DATA_X].<br /> 3. <strong>Используйте методы onPause()/onResume()</strong> для сохранения или закрытия всего того, что этого требует или того, что не должно быть открыто все время.<br /> 4. <strong>Создавайте ваши приложения работающими быстро и эффективно</strong>: обязательно изучитите доклады конференции <a href="http://www.youtube.com/watch?v=N6YdwzAvwOA">Google I/O 2009</a>. <br /> 5. <strong>Сложите два числа</strong>: ваше первое самостоятельное приложение  должно брать два числа и складывать их. Это звучит очень просто, но вы  можете потратить несколько часов для того, что бы вся разметка (<em>здесь и далее layout</em>), функции обратного вызова, методы onPause()/onResume() работали корректно.<br /> 6. <strong>Это Java</strong>: большая часть разработки приложения под Android &ndash;  это программирование на Java. Не тратьте время на критику или ее  восхваление. Просто программируйте.<br /> 7. <strong>Любите RelativeLayout</strong>: большинство примеров для начинающих используют LinearLayout, но вскоре вы узнаете, что RelativeLayout действительно полезен.<br /> 8. <strong>Используйте свойство &laquo;fill_parent&raquo; для самого первого RelativeLayout</strong>:  наиболее общей и трудно находимой проблемой является использование  свойства &laquo;wrap_content&raquo; для самого первого RelativeLayout и дальнейших  выяснений причин того, почему же некоторые элементы прорисовываются  странно.<br /> 9. <strong>Используйте &laquo;пустые&raquo; элементы разметки</strong>: часто вы будете  использовать пустые элементы в вашей разметке для относительного  позиционирования других элементов. Например, вы можете использовать  пустой TextField с нулевой высотой и шириной с параметром  &laquo;centerInParent&raquo; равным &laquo;true&raquo; только для того, что бы выравнять другие  элементы по центру экрана. <br /> 10. <strong>Используйте цвет фона для разметки</strong>: если у вас есть некоторые  проблемы с разметкой &mdash; попытайтесь установить цвет фона для некоторых  объектов. Это поможет выделить ваши ошибки быстрее, чем другие утилиты.<br /> 11. <strong>Скачайте &laquo;Apps-For-Android&raquo;</strong>: они содержат достаточно много  полезного исходного кода. И приятно дополняют стандартные примеры  приложений и показывают использование других решений в коде. Скачайте их  при помощи команды &laquo;svn co <a href="http://apps-for-android.googlecode.com/svn/trunk/apps-for-android-read-only">apps-for-android.googlecode.com/svn/trunk/apps-for-android-read-only</a>&raquo;.<br /> 12. <strong>Скачайте исходный код</strong>: исходный Android код необходим для  решения некоторых проблем и восполнения пробелов в документации. Не  обязательно, что бы это была последняя версия. Посетите <a href="http://android.git.kernel.org/">соответствующий сайт</a> для его получения.<br /> 13. <strong>Учитесь искать соответствующий исходный код</strong>: самое быстрое  решение для большинства проблем &mdash; это найти как используется  определенный параметр в другом исходном коде. Поместите копию примеров  приложений, приложений &laquo;apps-for-android&raquo; и любых других исходных кодов в  одну директорию. При помощи команды &laquo;grep -ir параметр  директория_с_исходным_кодом/&raquo; или любой другой программы вы легко  сможете найти как нужно использовать данный параметр.<br /> 14. <strong>Используйте Eclipse</strong>: даже если у вас есть другая любимая IDE  или редактор, который вы используете годами, применяйте Eclipse для  разработки под Android. Это достаточно хорошая IDE и для нее существует  множество утилит помогающих разработчику.<br /> 15. <strong>Изучите Eclipse</strong>: изучайте несколько новых трюков этой IDE каждый день. Мои любимые можно найти <a href="http://eclipse.dzone.com/news/effective-eclipse-shortcut-key">здесь</a> и <a href="http://stackoverflow.com/questions/54886/hidden-features-of-eclipse">здесь</a>.<br /> 16. <strong>Программируйте каждый день</strong>: программирование под Android  может вас разочаровать. Не позволяйте себе останавливаться. Используйте  утилиты, примеры приложений, читайте статьи. И снова пишите код.<br /> 17. <strong>Не используйте один монитор</strong>: работа за ноутбуком в кафе  замедлит вашу работу. Вам необходимо &laquo;разложить&raquo; окна приложений хотя бы  на пару экранов (окно Eclipse, эмулятор и документация). Работать с  тремя мониторами даже еще лучше.<br /> 18. <strong>Отформатируйте XML-файлы</strong>: используйте команду Source &ndash; Format  для приведения их в приемлемый вид. Если вы захотите выбрать следующий  параметр &laquo;Eclipse/Windows/Preferences/XML/XML  Files/Editor/Formatting/Split XML attributes each on a new line&raquo;, то  нажмите Ctrl + Shift + F для форматирования текста.<br /> 19. <strong>Редактируйте XML-файлы простым текстовым редактором</strong>: не используйте GUI для изменений свойств XML-тэгов.<br /> 20. <strong>Думайте о пиратстве в MarketPlace</strong>: Google не сделал  MarketPlace &laquo;счастливым местом&raquo;. Приложения копируются и публикуются  заново, но меняются только имена. Не планируйте жить исключительно на  поступления из AppStore.<br /> 21. <strong>Используйте LogCat</strong>: часто бывает сложно понять, что же пошло  не так. Запустите приложение в отладчике и посмотрите на вывод LogCat.  Если вам необходимо раскрасить вывод LogCat используйте <a href="http://jsharkey.org/blog/2009/04/22/modifying-the-android-logcat-stream-for-full-color-debugging/">Colored LogCat</a><br /> 22. <strong>Исследуйте директорию SDK с утилитами</strong>: существует много полезных утилит, таких как hierarchyviewer или layoutopt. Изучите их.<br /> 23. <strong>Обязательно прочтите следующие статьи</strong>: <a href="http://developer.android.com/guide/practices/design/performance.html">дизайн и производительность в Android</a>, <a href="http://developer.motorola.com/docstools/library/Best_Practices_for_User_Interfaces/">лучшие практики пользовательских интерфейсов</a>, <a href="http://stackoverflow.com/questions/1002492/android-best-practice-for-responsive-user-interfaces">лучшие практики &laquo;отзывчивых&raquo; пользовательских интерфейсов</a> и <a href="http://stackoverflow.com/questions/522312/best-practices-for-unit-testing-android-apps">лучшие практики unit-тестов Android приложений</a>. <br /> 24. <strong>Не копируйте образцы пользовательских интерфейсов с других платформ (особенно с iPhone)</strong>: я видел много приложений, которые пытаются копировать &laquo;tab bar&raquo;, который есть у многих приложений на iPhone (<a href="http://a2.mzstatic.com/us/r1000/028/Purple/b5/1a/66/mzl.eoggmutd.320x480-75.jpg">android</a> и <a href="https://g0.gstatic.com/android/market/com.aol.mobile.engadget/ss-480-0-6">iPhone</a>).  Я против этого. Это смотрится не к месту, не естественно для платформы и  засоряет экран. Также, это трудно реализовать, так как SDK никак не  помогает в создании этого и вам придется писать это с нуля. Вместо  этого, используйте кнопку Menu. <br /> 25. <strong>Запуск намерений (Intents)</strong>: всегда запускайте намерения при помощи отдельного метода и называйте этот метод соответствующим образом.<br /> 26. <strong>Сборщик мусора</strong>: запуск сборщика мусора виртуальной машины  Dalvik очень &laquo;дорог&raquo;. Он легко может заблокировать пользовательский  интерфейс. Если вам необходим плавный скорллинг, вы должны избегать  создания множества объектов. Предпочтительно использовать существующие  объекты и не создавать новых. Игра <a href="http://code.google.com/p/replicaisland/">Replica Island</a> &mdash; это игра с исходным кодом, которая использует этот прием. Исследуйте  ее исходные коды. Также вы сможете анализировать создание объектов в  приложении на закладке &laquo;Allocation Tracker&raquo; в DDMS. <br /> 27. <strong>Потоки</strong>: запуск нового потока достаточно &laquo;дорог&raquo;. Используйте  только один поток, который выполняет задачи одна за одной или  используйте пулы потоков (thread pools). Если необходимо, используйте  встроенные классы, такие как AsyncTask. <br /> 28. <strong>Большие объемы данных</strong>: если ваши данные занимают достаточно  большой объем (более 100Кб) &mdash; не сохраняйте их в текстовых или  XML-файлах. Их парсинг будет слишком &laquo;дорог&raquo;. Используйте SQLite.<br /> 29. <strong>Eclipse MAT</strong>: Eclipse Memory Analyzer это хорошая утилита для  анализа выделений памяти. Она поможет вам найти утечки памяти в вашем  приложении. <br /> 30. <strong>Метод onDestroy</strong>: переопределяйте метод onDestroy для того, что бы &laquo;убрать за собой&raquo;.<br /> 31. <strong>Антивирус</strong>: если вы пользуетесь антивирусом, то исключите  директории, где расположен эмулятор из сканирования: образы эмуляторов  обычно хранятся в пользовательской директории (например, C:\\Documents  and Settings\\Users.android), директорию Eclipse и директорию, где  расположен Android SDK. Если вы отключите сканирование этих директорий  скорость программирования и отладки может значительно возрасти.</p>', '<p>Данная статья является переводом очень хорошего <a href="http://stackoverflow.com/questions/2961049/effective-android-programming-techniques">топика</a> с форума Stack Overflow. Так как английский язык не является для меня  родным, то какие-либо непонятные мне места я просто пропускал, что бы не  разгневать тех, кто его действительно знает. Статья содержит список  советов и рекомендаций для начинающих разработчиков под Android.</p>\r\n', 'android, blog', 2, 0, 1322078538, 1322078688);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_tag`
-- 

CREATE TABLE `tbl_tag` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(128) collate utf8_unicode_ci NOT NULL,
  `frequency` int(11) default '1',
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=6 ;

-- 
-- Дамп данных таблицы `tbl_tag`
-- 

INSERT INTO `tbl_tag` VALUES (1, 'yii', 3);
INSERT INTO `tbl_tag` VALUES (2, 'blog', 2);
INSERT INTO `tbl_tag` VALUES (3, 'test', 1);
INSERT INTO `tbl_tag` VALUES (4, 'date', 1);
INSERT INTO `tbl_tag` VALUES (5, 'android', 1);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_user`
-- 

CREATE TABLE `tbl_user` (
  `id` int(11) NOT NULL auto_increment,
  `group_id` int(11) NOT NULL default '0',
  `username` varchar(128) NOT NULL,
  `password` varchar(128) NOT NULL,
  `role` varchar(128) NOT NULL,
  `create_time` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_user`
-- 

INSERT INTO `tbl_user` VALUES (1, 2, 'admin', '4d7a85863bf3861a5523407eab522010', 'administrator', 1321448929);
INSERT INTO `tbl_user` VALUES (2, 1, 'ATI', '4d7a85863bf3861a5523407eab522010', 'moderator', 1321467751);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_user_group`
-- 

CREATE TABLE `tbl_user_group` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(255) NOT NULL,
  `slug` varchar(255) NOT NULL,
  `level` int(11) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_user_group`
-- 

INSERT INTO `tbl_user_group` VALUES (1, 'Тестовики', 'administrators', 1);
INSERT INTO `tbl_user_group` VALUES (2, 'Команда Тестеров', 'tester_team', 1);

-- --------------------------------------------------------

-- 
-- Структура таблицы `tbl_user_profile`
-- 

CREATE TABLE `tbl_user_profile` (
  `id` int(11) NOT NULL auto_increment,
  `user_id` int(11) NOT NULL,
  `first_name` varchar(255) NOT NULL,
  `last_name` varchar(255) NOT NULL,
  `email` varchar(255) NOT NULL,
  `phone` varchar(255) NOT NULL,
  `birthday` date NOT NULL,
  `avatar` varchar(255) NOT NULL,
  `level` tinyint(3) NOT NULL,
  `last_login` int(11) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=3 ;

-- 
-- Дамп данных таблицы `tbl_user_profile`
-- 

INSERT INTO `tbl_user_profile` VALUES (1, 1, 'Alexander', 'Stanovoy', 'soccer007@mail.ru', '', '1988-07-13', '19_11_2011_13_02_26_admin.jpg', 1, 1321449007);
INSERT INTO `tbl_user_profile` VALUES (2, 2, '', '', 'ati@mail.ru', '', '1988-07-13', '19_11_2011_13_00_56_ATI.gif', 0, 0);
